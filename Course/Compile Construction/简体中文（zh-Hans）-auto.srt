1
00:01:02,960 --> 00:01:09,530
好吧，让我们开始这样 的主题 

2
00:01:07,320 --> 00:01:12,510
本周谈论优化 

3
00:01:09,530 --> 00:01:15,660
我们创建的汇编输出也可以 

4
00:01:12,510 --> 00:01:19,110
采取我们所拥有的这些计划

5
00:01:15,660 --> 00:01:22,200
输入并在前往结果的路上 

6
00:01:19,110 --> 00:01:24,630
装配我们可以做智能事情 

7
00:01:22,200 --> 00:01:27,570
避免产生这么多

8
00:01:24,630 --> 00:01:30,119
说明或我们可以生成更聪明的

9
00:01:27,570 --> 00:01:33,600
指令使用更少的内存所有这些 

10
00:01:30,119 --> 00:01:37,320
各种各样的事情 ，今天我 想 

11
00:01:33,600 --> 00:01:39,420
谈谈有三种想法 

12
00:01:37,320 --> 00:01:43,200
三个不同的 想法落入 

13
00:01:39,420 --> 00:01:48,600
三种不同类别 的编译器 

14
00:01:43,200 --> 00:01:52,320
优化有三种 

15
00:01:48,600 --> 00:01:54,000
表面上的小想法，如果你 

16
00:01:52,320 --> 00:01:58,470
我想投入大量详细的工作 

17
00:01:54,000 --> 00:02:01,080
或写GCC团队想要投入 

18
00:01:58,470 --> 00:02:04,020
你可以看到多年的详细工作 

19
00:02:01,080 --> 00:02:06,149
轨迹跨越你的方式

20
00:02:04,020 --> 00:02:09,899
越来越多的精力投入到这件事情 

21
00:02:06,149 --> 00:02:12,900
在 131我们 真的很好 

22
00:02:09,899 --> 00:02:14,790
没有成千上万的男人 

23
00:02:12,900 --> 00:02:16,860
和女人的时间 投入 我们的 

24
00:02:14,790 --> 00:02:20,370
编译器是什么进入了

25
00:02:16,860 --> 00:02:22,500
像GCC 这样的编译器有很多 

26
00:02:20,370 --> 00:02:24,180
思考许多不同的案例 

27
00:02:22,500 --> 00:02:27,390
所以我们要谈谈 一些 

28
00:02:24,180 --> 00:02:28,970
今天 几个 有趣的案例 

29
00:02:27,390 --> 00:02:31,500
不同 种类的编译器 

30
00:02:28,970 --> 00:02:34,069
我们可能尝试优化，这些是

31
00:02:31,500 --> 00:02:36,630
其实类似的事情 ， 

32
00:02:34,069 --> 00:02:37,739
海湾合作委员会只做了第一件事 

33
00:02:36,630 --> 00:02:39,750
我们要谈论 的 实际 

34
00:02:37,739 --> 00:02:43,020
前两 件事是GCC的事情 

35
00:02:39,750 --> 00:02:46,099
特别是我所拥有的 

36
00:02:43,020 --> 00:02:49,260
屏幕在这里是在左侧我 

37
00:02:46,099 --> 00:02:52,980
刚刚复制了我们的代码 

38
00:02:49,260 --> 00:02:58,160
参考实现 ii-if from 

39
00:02:52,980 --> 00:03:01,920
像眼镜蛇和 响尾蛇 ， 它的 

40
00:02:58,160 --> 00:03:04,709
如果需要做的话，做什么编译

41
00:03:01,920 --> 00:03:07,440
这里调用 的条件 表达式 

42
00:03:04,709 --> 00:03:09,190
如果exper检查它是否是布尔值 

43
00:03:07,440 --> 00:03:11,110
因为在我们的 

44
00:03:09,190 --> 00:03:13,840
我们的语言我们关心 这些 

45
00:03:11,110 --> 00:03:15,340
欺负ins 然后它有代码 

46
00:03:13,840 --> 00:03:16,690
当时的分支， 该代码

47
00:03:15,340 --> 00:03:20,530
else分支，它检查 真实性 

48
00:03:16,690 --> 00:03:25,350
我 的 右手 也是如此 

49
00:03:20,530 --> 00:03:29,820
方是一个更详细的模式匹配 

50
00:03:25,350 --> 00:03:34,240
e如果那时在左侧 a 

51
00:03:29,820 --> 00:03:37,210
更详细的模式匹配比什么 

52
00:03:34,240 --> 00:03:40,120
在左手边这么 左手 

53
00:03:37,210 --> 00:03:45,430
边匹配将匹配看起来的程序 

54
00:03:40,120 --> 00:03:49,540
就像X，然后一些II 1 LC 2他们会 

55
00:03:45,430 --> 00:03:53,950
匹配看起来像某些东西的东西

56
00:03:49,540 --> 00:03:55,870
函数调用某个值 所以匹配任何 值 

57
00:03:53,950 --> 00:03:58,090
如果表达 我们可以 

58
00:03:55,870 --> 00:03:59,950
写一个 你写的表达式if if 

59
00:03:58,090 --> 00:04:01,780
你解析它把它变成抽象的 

60
00:03:59,950 --> 00:04:04,450
语法并将其与该案例进行匹配 

61
00:04:01,780 --> 00:04:07,540
它会匹配，这就是编译 

62
00:04:04,450 --> 00:04:11,680
对于它， 只有 右手边的情况 

63
00:04:07,540 --> 00:04:21,790
如果表达式看起来匹配 

64
00:04:11,680 --> 00:04:23,560
喜欢 这里 的 名字 保持 不变 

65
00:04:21,790 --> 00:04:25,480
一些表达， 然后在其他 

66
00:04:23,560 --> 00:04:28,150
拥有它只会 匹配 

67
00:04:25,480 --> 00:04:30,460
事情呐喊 更大而不是更少 

68
00:04:28,150 --> 00:04:32,200
只会去匹配的地方 

69
00:04:30,460 --> 00:04:36,610
条件位置的东西有一个

70
00:04:32,200 --> 00:04:41,560
大于第一个问题可以吗？ 

71
00:04:36,610 --> 00:04:43,750
谈谈我们可能会有什么 

72
00:04:41,560 --> 00:04:46,090
如果我们知道的话，可以做得更好 

73
00:04:43,750 --> 00:04:47,980
如果我们知道的话，与这种情况相匹 

74
00:04:46,090 --> 00:04:49,060
我们只是匹配ifs 

75
00:04:47,980 --> 00:04:52,420
这种情况我们有一个大于 

76
00:04:49,060 --> 00:04:53,830
我们能做些什么才能做得更好 

77
00:04:52,420 --> 00:04:55,570
那会更聪明 

78
00:04:53,830 --> 00:04:57,790
我们正在生成的指令

79
00:04:55,570 --> 00:05:00,610
所有通用案例都是这样的 

80
00:04:57,790 --> 00:05:01,750
只需30秒 左右我们能做 什么 

81
00:05:00,610 --> 00:05:04,170
那样做会更聪明 

82
00:05:01,750 --> 00:05:04,170
右侧 

83
00:05:40,040 --> 00:05:48,400
有没有讲谈 了谈 

84
00:05:43,190 --> 00:05:48,400
关于它谈谈谈话 

85
00:06:31,300 --> 00:06:37,660
好的想法有一些不同的 想法 

86
00:06:34,060 --> 00:06:39,700
在这个空间，但如果我们有想法的想法 

87
00:06:37,660 --> 00:06:49,780
这些额外的信息我们可以做些什么 

88
00:06:39,700 --> 00:07:03,610
做的更好什么 有一些想法， 我看 

89
00:06:49,780 --> 00:07:05,620
点头的想法，如果哦所以你说是否 

90
00:07:03,610 --> 00:07:07,180
我们对1和2有所了解 

91
00:07:05,620 --> 00:07:11,200
让我们想象一下 让我们得到 更多 

92
00:07:07,180 --> 00:07:12,790
具体你说 另一个 

93
00:07:11,200 --> 00:07:14,050
想法所以我只是 要去把虚线 

94
00:07:12,790 --> 00:07:16,810
这里，所以我们知道我们在谈论 

95
00:07:14,050 --> 00:07:19,060
更具体的东西 但如果我们想要的话 

96
00:07:16,810 --> 00:07:24,790
谈 事情，其中一个或多个 

97
00:07:19,060 --> 00:07:27,070
在这种情况下，这些是数字 

98
00:07:24,790 --> 00:07:28,600
在这种情况下，我们可以说我们很好 

99
00:07:27,070 --> 00:07:30,520
绝对只需要说明 

100
00:07:28,600 --> 00:07:33,010
对于else 分支，因为这是 

101
00:07:30,520 --> 00:07:34,150
总是要评价 为假 

102
00:07:33,010 --> 00:07:36,190
这就是你正确得到的 

103
00:07:34,150 --> 00:07:37,630
如果我们知道的话更加正确 

104
00:07:36,190 --> 00:07:40,570
我可以进行更详细的比赛

105
00:07:37,630 --> 00:07:42,570
写在哪里而不是有一个e1和 

106
00:07:40,570 --> 00:07:45,700
e2在这里我可以写出 类似的东西 

107
00:07:42,570 --> 00:07:49,570
如果这两个数字都正确怎么办？ 

108
00:07:45,700 --> 00:07:51,970
这是一个 想法，我们 很酷 

109
00:07:49,570 --> 00:07:53,980
可能会使用实际上 会使用这个想法 

110
00:07:51,970 --> 00:07:55,960
与后来 在后面的 

111
00:07:53,980 --> 00:07:58,180
但是如果 我们不知道怎么办呢 

112
00:07:55,960 --> 00:08:02,530
E还有更多的东西 -  

113
00:07:58,180 --> 00:08:04,540
耶可以节省一个布尔检查 ÿ 请 

114
00:08:02,530 --> 00:08:07,150
我们可以保存一个布尔检查， 也许我们 

115
00:08:04,540 --> 00:08:11,740
可以保存布尔检查其他想法 

116
00:08:07,150 --> 00:08:14,230
什么也可以节省一个 

117
00:08:11,740 --> 00:08:15,970
分支也可能保存分支 

118
00:08:14,230 --> 00:08:17,380
保存布尔检查保存的想法

119
00:08:15,970 --> 00:08:20,490
分支我们会回到其他人那里 

120
00:08:17,380 --> 00:08:20,490
想法其他想法 

121
00:08:24,169 --> 00:08:27,319
好吧，我会回来说为什么可以 

122
00:08:26,090 --> 00:08:37,669
我们跳过 布尔检查为什么会这样 

123
00:08:27,319 --> 00:08:39,440
好的 ，如果有 错误 的话会怎样 

124
00:08:37,669 --> 00:08:46,190
如果您想要 导致错误怎么办？ 

125
00:08:39,440 --> 00:08:50,630
那么我怎么知道啊所以大于 

126
00:08:46,190 --> 00:08:52,130
II 1或e 2产生错误或 

127
00:08:50,630 --> 00:08:54,410
他们的非数字大于 

128
00:08:52,130 --> 00:08:56,779
产生错误，在这种情况下

129
00:08:54,410 --> 00:08:59,240
程序完成后我们不用 担心 

130
00:08:56,779 --> 00:09:01,970
关于这个子表达的答案

131
00:08:59,240 --> 00:09:03,470
因为我们得到了一个错误 ，这个 

132
00:09:01,970 --> 00:09:05,480
在许多语言中都是如此

133
00:09:03,470 --> 00:09:07,339
Java 你不再担心了 

134
00:09:05,480 --> 00:09:09,290
回答这个子表达式和一个if 

135
00:09:07,339 --> 00:09:10,760
如果抛出一些异常 

136
00:09:09,290 --> 00:09:12,170
异常处理程序会处理你 

137
00:09:10,760 --> 00:09:16,640
不必担心本地 

138
00:09:12,170 --> 00:09:19,880
这里大于总是返回一个 

139
00:09:16,640 --> 00:09:21,800
布尔总是把一个布尔值在EAX 作为 

140
00:09:19,880 --> 00:09:23,449
只要它成功， 我们不必 

141
00:09:21,800 --> 00:09:25,010
担心失败的情况因为 

142
00:09:23,449 --> 00:09:26,630
我们在这里生成的代码不是 

143
00:09:25,010 --> 00:09:29,870
代码不是代码 

144
00:09:26,630 --> 00:09:31,699
处理错误所以我们 知道，因为我们知道 

145
00:09:29,870 --> 00:09:36,230
那个结果 必须更大 

146
00:09:31,699 --> 00:09:43,430
一个 布尔值 ，我们不需要这个整个测试 

147
00:09:36,230 --> 00:09:46,250
bool chunk 这部分插入 

148
00:09:43,430 --> 00:09:47,209
测试池的代码以及我们添加它的位置 

149
00:09:46,250 --> 00:09:51,260
在这里的列表中

150
00:09:47,209 --> 00:09:53,560
这些不需要成为其中的一部分 

151
00:09:51,260 --> 00:09:53,560
比赛

152
00:09:57,420 --> 00:10:01,930
如果我们只是 考虑 移动 

153
00:09:59,620 --> 00:10:04,120
代码结束 并实现它 

154
00:10:01,930 --> 00:10:05,440
在这里匹配案例现在 我们还在 

155
00:10:04,120 --> 00:10:07,330
要去必须做一些东西 ， 有 

156
00:10:05,440 --> 00:10:09,130
用if和 then 和else做 

157
00:10:07,330 --> 00:10:10,510
以及那些编译它们的东西 

158
00:10:09,130 --> 00:10:12,310
子表达式，但我们不需要 

159
00:10:10,510 --> 00:10:13,960
测试池你 建议我们 

160
00:10:12,310 --> 00:10:16,150
可以摆脱一个分支机构 是一个 

161
00:10:13,960 --> 00:10:17,650
从中间的建议是 什么 

162
00:10:16,150 --> 00:10:25,510
分支案例， 你建议我们可以 

163
00:10:17,650 --> 00:10:29,260
摆脱，如果我们实施大于

164
00:10:25,510 --> 00:10:31,390
有分支哦，所以你说 我们喜欢 

165
00:10:29,260 --> 00:10:33,190
里面大于操作那里 

166
00:10:31,390 --> 00:10:36,310
可能是那里的一个分支，我们可以 

167
00:10:33,190 --> 00:10:37,750
让那个分支改为做if事 

168
00:10:36,310 --> 00:10:40,360
所以也许我们可以弄巧 用 

169
00:10:37,750 --> 00:10:42,340
编译大于此类 

170
00:10:40,360 --> 00:10:44,740
与if同时如此 

171
00:10:42,340 --> 00:10:47,550
那里有一些机会没关系 

172
00:10:44,740 --> 00:10:51,460
所以也许我们可以深入研究 

173
00:10:47,550 --> 00:10:53,290
探索那个选项 的重点我 

174
00:10:51,460 --> 00:10:54,790
当我提出这个问题时，请记住

175
00:10:53,290 --> 00:10:56,830
有趣的想法我没有这个想法 

176
00:10:54,790 --> 00:10:58,210
当我选择这个例子的时候

177
00:10:56,830 --> 00:10:59,710
我挑选的时候我 想到的主要事情

178
00:10:58,210 --> 00:11:02,260
这个例子指出了这个bool 

179
00:10:59,710 --> 00:11:05,350
我们可以摆脱这个布尔值的情况 

180
00:11:02,260 --> 00:11:08,830
凭借我们知道的事实来检查 

181
00:11:05,350 --> 00:11:10,450
如果我们在 if中 做得更好 

182
00:11:08,830 --> 00:11:11,980
它会有条件的位置

183
00:11:10,450 --> 00:11:14,170
产生一个布尔值，所以没有必要 

184
00:11:11,980 --> 00:11:16,750
检查没有办法省略这个 

185
00:11:14,170 --> 00:11:18,490
代码可能导致该程序有一个 

186
00:11:16,750 --> 00:11:20,500
不同的答案或有错误的时候 

187
00:11:18,490 --> 00:11:22,990
它 之前没有错误 

188
00:11:20,500 --> 00:11:24,340
会有相同的答案，所以 

189
00:11:22,990 --> 00:11:25,900
非常有趣它意味着我们 

190
00:11:24,340 --> 00:11:28,630
可以写出这些更详细的比赛 

191
00:11:25,900 --> 00:11:30,220
关于当前一些表达的案例

192
00:11:28,630 --> 00:11:33,070
编译器，我们有这个特别

193
00:11:30,220 --> 00:11:36,130
在执行这些标记的表达式中很有用

194
00:11:33,070 --> 00:11:37,420
检查错误， 但还有其他 错误 

195
00:11:36,130 --> 00:11:39,310
情况下，这可能是 有用的 ，以及 

196
00:11:37,420 --> 00:11:42,280
我们可以写出这些更详细的匹配 

197
00:11:39,310 --> 00:11:44,140
病例和选择做一个更好的工作

198
00:11:42,280 --> 00:11:48,160
我们为a生成的指令

199
00:11:44,140 --> 00:11:52,720
给出表达所以这个网站这个想法 

200
00:11:48,160 --> 00:11:57,880
有一个名字，我只是要把它写下来

201
00:11:52,720 --> 00:11:59,830
在这里， 这个 想法 很好 

202
00:11:57,880 --> 00:12:03,970
真的 - 这是 一个庞大的 家庭 

203
00:11:59,830 --> 00:12:07,750
这里 的 技术， 但总体思路是 

204
00:12:03,970 --> 00:12:09,670
称为指令选择，这是 

205
00:12:07,750 --> 00:12:12,310
现在就明白这个想法 

206
00:12:09,670 --> 00:12:15,940
我们为每个人写了一个案例 

207
00:12:12,310 --> 00:12:18,430
用我们的语言表达右EF 

208
00:12:15,940 --> 00:12:22,480
有与 它 匹配 的 一个案例 

209
00:12:18,430 --> 00:12:23,890
编译器EBU欺负数量 应用程序的一切 

210
00:12:22,480 --> 00:12:26,200
有一个案例匹配 它 

211
00:12:23,890 --> 00:12:27,760
编译器，只有一个 选项 

212
00:12:26,200 --> 00:12:31,210
我们为每个人生成哪些指令

213
00:12:27,760 --> 00:12:34,060
表达我们生成它和想法 

214
00:12:31,210 --> 00:12:37,600
如果我们 ，教学选择很好 

215
00:12:34,060 --> 00:12:39,730
有关正在发生的 事情的 更多信息 

216
00:12:37,600 --> 00:12:41,010
在表达式上我们可以 做一些 

217
00:12:39,730 --> 00:12:44,590
我们生成代码时更聪明的事情

218
00:12:41,010 --> 00:12:48,520
省略省略这样的检查是 

219
00:12:44,590 --> 00:12:49,930
一个想法， 所以我想谈谈这个 

220
00:12:48,520 --> 00:12:51,940
更普遍的，但之前我说说 

221
00:12:49,930 --> 00:12:54,790
更普遍的是我想提几个 

222
00:12:51,940 --> 00:12:56,680
这里的例子是另一套 

223
00:12:54,790 --> 00:13:03,340
这里的示例是嵌套匹配 

224
00:12:56,680 --> 00:13:08,770
加上他们需要一些信件 

225
00:13:03,340 --> 00:13:11,040
我要问 的问题 是 

226
00:13:08,770 --> 00:13:11,040
这些

227
00:13:22,910 --> 00:13:27,270
其中哪些不会让我们跳过标签 

228
00:13:25,290 --> 00:13:29,010
检查正确，所以我们只是看到了如果我们 

229
00:13:27,270 --> 00:13:31,200
知道 有条件的东西 

230
00:13:29,010 --> 00:13:32,700
在if中的位置比我们大 

231
00:13:31,200 --> 00:13:34,590
可以跳过 标签检查 布尔值 

232
00:13:32,700 --> 00:13:36,930
它有什么关于这个所以 这些 在这里的四 

233
00:13:34,590 --> 00:13:38,930
嵌套嵌套二进制文件的选项

234
00:13:36,930 --> 00:13:42,660
运营商

235
00:13:38,930 --> 00:13:44,370
好吧，让我们这样做应该说得好 

236
00:13:42,660 --> 00:13:54,440
这应该说EEPROM 约对不起 

237
00:13:44,370 --> 00:13:54,440
那只是为了那种方式的一致性 

238
00:14:18,150 --> 00:14:28,170
五四三二一 

239
00:14:24,290 --> 00:14:29,370
好吧， 有 一种奇怪的感觉 

240
00:14:28,170 --> 00:14:31,980
这些选项所以我想让你 谈谈 

241
00:14:29,370 --> 00:14:34,520
关于它只是 20 或 30秒 

242
00:14:31,980 --> 00:14:34,520
简单地谈谈它 

243
00:15:03,510 --> 00:15:09,779
好吧那么首先是什么呢 

244
00:15:06,420 --> 00:15:11,459
这里 或者 至少 是什么 答案 

245
00:15:09,779 --> 00:15:15,779
就像 这里 最明显的 答案一样 

246
00:15:11,459 --> 00:15:17,730
好吧在 B和C 我们正在做一个加号 和 

247
00:15:15,779 --> 00:15:20,670
那么我们知道 第 一个论点是 

248
00:15:17,730 --> 00:15:22,320
无论是数字还是其他加上 我们 

249
00:15:20,670 --> 00:15:23,639
知道数字不好 

250
00:15:22,320 --> 00:15:25,440
需要检查数字和 

251
00:15:23,639 --> 00:15:27,959
我们知道plus plus表达式

252
00:15:25,440 --> 00:15:29,820
我们可以在B和C中返回数字

253
00:15:27,959 --> 00:15:32,160
绝对省略标签检查

254
00:15:29,820 --> 00:15:35,310
第一个参数我们没有检查 

255
00:15:32,160 --> 00:15:38,339
这个表达式的标签或者这个 

256
00:15:35,310 --> 00:15:40,019
表达我们 可以跳过它，也许 

257
00:15:38,339 --> 00:15:43,290
甚至产生 更加智能 

258
00:15:40,019 --> 00:15:46,410
在第一种情况下的说明 

259
00:15:43,290 --> 00:15:50,600
如果我们有一个功能，请回答

260
00:15:46,410 --> 00:15:53,579
申请我们不知道那么多 

261
00:15:50,600 --> 00:15:55,410
本地到这个模式 匹配 什么 

262
00:15:53,579 --> 00:15:57,510
可能会从那里归还

263
00:15:55,410 --> 00:15:58,680
以我们编译器的方式运行 

264
00:15:57,510 --> 00:16:00,750
设置我们根本不知道 多少 

265
00:15:58,680 --> 00:16:04,230
函数的返回值 直到我们 

266
00:16:00,750 --> 00:16:06,269
称他们为选项 A这 真的很难 

267
00:16:04,230 --> 00:16:08,250
看看我们如何跳过支票检查

268
00:16:06,269 --> 00:16:09,630
通过 使用选项我们必须 做 

269
00:16:08,250 --> 00:16:12,240
函数调用看看 回来了什么 

270
00:16:09,630 --> 00:16:15,839
然后做加法与它 使 

271
00:16:12,240 --> 00:16:17,699
这里最明显的答案 是a和 它 

272
00:16:15,839 --> 00:16:20,010
一些预期的答案， 但D是 

273
00:16:17,699 --> 00:16:22,500
故意怪异的B是故意的 

274
00:16:20,010 --> 00:16:30,930
很奇怪D的奇怪之处是什么 

275
00:16:22,500 --> 00:16:35,100
关于D是的是的，是 的， 是的 

276
00:16:30,930 --> 00:16:38,100
肯定会产生一个布尔值 

277
00:16:35,100 --> 00:16:40,279
意味着加号表达肯定 

278
00:16:38,100 --> 00:16:44,329
在运行时会导致错误 

279
00:16:40,279 --> 00:16:46,589
这就像一个已知的错误案例 

280
00:16:44,329 --> 00:16:49,199
这肯定会导致一个 

281
00:16:46,589 --> 00:16:52,860
错误 所以 有趣的事情 

282
00:16:49,199 --> 00:16:54,810
这是等我们有一点点 

283
00:16:52,860 --> 00:16:56,399
设计决定 如果我们做 什么 

284
00:16:54,810 --> 00:16:58,170
是为了匹配我们的表达

285
00:16:56,399 --> 00:17:02,250
知道会导致错误 

286
00:16:58,170 --> 00:17:03,930
运行时根据我们的定义 

287
00:17:02,250 --> 00:17:05,790
优化我们应该怎样做，我们 

288
00:17:03,930 --> 00:17:07,079
我们有一个优化的定义

289
00:17:05,790 --> 00:17:11,069
周一给了我们应该怎么做

290
00:17:07,079 --> 00:17:12,329
是的， 也许可以调用错误 

291
00:17:11,069 --> 00:17:14,220
马上就马上马上吧 

292
00:17:12,329 --> 00:17:16,939
我们应该做这个时间概念

293
00:17:14,220 --> 00:17:16,939
它在编译器中 

294
00:17:17,209 --> 00:17:20,299
会是，也许就像马上一样 

295
00:17:18,500 --> 00:17:26,839
尽可能正确 

296
00:17:20,299 --> 00:17:36,590
失败与坏的权利让我们给一个 

297
00:17:26,839 --> 00:17:39,250
优化 的编译器定义 说 

298
00:17:36,590 --> 00:17:39,250
虽然这个

299
00:17:44,260 --> 00:17:56,240
那是什么，所以我们的 定义 

300
00:17:52,970 --> 00:18:04,930
优化关键部分是有

301
00:17:56,240 --> 00:18:08,270
同样的答案和效果是 

302
00:18:04,930 --> 00:18:10,880
哎呀，这是我们的关键部分

303
00:18:08,270 --> 00:18:12,410
优化定义就是我们

304
00:18:10,880 --> 00:18:13,790
可能生成不同的指令

305
00:18:12,410 --> 00:18:16,160
这可能会做些不同的事情 

306
00:18:13,790 --> 00:18:17,540
速度或内存使用方面但是 

307
00:18:16,160 --> 00:18:21,940
我们生成的程序应该有

308
00:18:17,540 --> 00:18:24,860
同样的答案 和相同的效果 ，让 

309
00:18:21,940 --> 00:18:27,560
我们有几个地方 

310
00:18:24,860 --> 00:18:30,380
我们 可能有答案和 未来 的影响 

311
00:18:27,560 --> 00:18:32,600
在这里所以并在 特定 的 一个 

312
00:18:30,380 --> 00:18:34,670
我们可能有些有趣的地方

313
00:18:32,600 --> 00:18:40,340
发生了，他们就像是强调了 

314
00:18:34,670 --> 00:18:43,600
现在就在这里，我们要走了 

315
00:18:40,340 --> 00:18:46,820
这 比两个人的操作 更重要 

316
00:18:43,600 --> 00:18:49,820
表达式如果有 效果会 怎样 

317
00:18:46,820 --> 00:18:51,080
如果它们有效果会怎么样？ 

318
00:18:49,820 --> 00:18:53,090
程序员期待着什么

319
00:18:51,080 --> 00:18:54,770
发生在那里我想让你思考 

320
00:18:53,090 --> 00:18:58,930
约 一分钟什么的例子 

321
00:18:54,770 --> 00:18:58,930
一个程序这是一个 程序 的示例 

322
00:19:09,930 --> 00:19:14,830
这有更大的影响 

323
00:19:12,880 --> 00:19:16,900
位置谈论这个对我来说有什么用 

324
00:19:14,830 --> 00:19:19,300
我的意思是 说 什么的一个例子 

325
00:19:16,900 --> 00:19:22,120
程序有在那里我已经影响 

326
00:19:19,300 --> 00:19:23,620
将这两个下划线圈在附近 

327
00:19:22,120 --> 00:19:25,270
更大的是 一个程序 的 例子 

328
00:19:23,620 --> 00:19:27,600
这 有影响 ，谈论这个 

329
00:19:25,270 --> 00:19:27,600
一分钟 

330
00:20:05,910 --> 00:20:10,299
好的，所以这里是这里的一个 

331
00:20:08,650 --> 00:20:13,330
我 是一个 更简单的例子 

332
00:20:10,299 --> 00:20:15,940
可以想到说明这个或在 

333
00:20:13,330 --> 00:20:18,809
如果我们有一个，那么至少是最短的 

334
00:20:15,940 --> 00:20:18,809
程序是这样的 

335
00:20:27,400 --> 00:20:31,789
我们是一个添加结果的程序 

336
00:20:30,440 --> 00:20:36,860
大于打印一些 

337
00:20:31,789 --> 00:20:39,620
表达式现在这意味着如果 

338
00:20:36,860 --> 00:20:41,720
我们 运行了一个未经授权的编译器 

339
00:20:39,620 --> 00:20:43,669
会打印一张打印件来比较它们 

340
00:20:41,720 --> 00:20:45,350
大于然后错误 

341
00:20:43,669 --> 00:20:46,760
再加上我认为 这就是 这个程序 

342
00:20:45,350 --> 00:20:49,520
如果我们在未经优化的情况下运行它会怎么做 

343
00:20:46,760 --> 00:20:52,309
编译器如果我们的优化排序 

344
00:20:49,520 --> 00:20:54,350
拿出来或取出那个操作 

345
00:20:52,309 --> 00:20:56,270
或者我们会在一开始就失败了

346
00:20:54,350 --> 00:20:58,100
切换到优化编译器和 

347
00:20:56,270 --> 00:21:00,530
事情会有所不同 

348
00:20:58,100 --> 00:21:02,990
他们是 我们的计划， 如果我们 不运行 

349
00:21:00,530 --> 00:21:05,150
刚刚在这里失败，如果我们跳过了 

350
00:21:02,990 --> 00:21:07,610
这样做是因为它是 

351
00:21:05,150 --> 00:21:09,530
我们 只会看到 一个错误 

352
00:21:07,610 --> 00:21:12,530
不同的答案出来可能会看到一个 

353
00:21:09,530 --> 00:21:14,480
如果 曾经是一个错误，那就 回答 

354
00:21:12,530 --> 00:21:16,309
我们要坚持 这个定义 

355
00:21:14,480 --> 00:21:18,919
我正在争论的优化是一个 

356
00:21:16,309 --> 00:21:21,580
好主意我们 可能会跳过一些 

357
00:21:18,919 --> 00:21:24,799
在这里工作就像我们知道如果更大 

358
00:21:21,580 --> 00:21:26,870
我们应该最终得到答案

359
00:21:24,799 --> 00:21:28,490
错误， 所以我们可以跳过 

360
00:21:26,870 --> 00:21:30,409
做实际的加，因为我们知道 

361
00:21:28,490 --> 00:21:32,929
这会 产生一个错误，但我们 

362
00:21:30,409 --> 00:21:36,850
不应该完全避免编译

363
00:21:32,929 --> 00:21:39,140
这或将其变成编译错误 

364
00:21:36,850 --> 00:21:40,730
这可能是我们做出的设计决定 

365
00:21:39,140 --> 00:21:42,169
关于尝试和报告 的 语言 

366
00:21:40,730 --> 00:21:44,299
像这样的错误 ，现在说 

367
00:21:42,169 --> 00:21:46,220
语言被更改 并报告这些 

368
00:21:44,299 --> 00:21:48,559
编译器中的各种错误，但我们 

369
00:21:46,220 --> 00:21:51,020
不应该改变优化器

370
00:21:48,559 --> 00:21:52,820
该 程序的 程序 的行为

371
00:21:51,020 --> 00:21:54,409
用来打印出来的东西 

372
00:21:52,820 --> 00:21:59,000
优化它应该仍然打印相同 

373
00:21:54,409 --> 00:22:01,940
事情没关系 所以这个 整体想法 

374
00:21:59,000 --> 00:22:03,799
整体想法出现在我们的

375
00:22:01,940 --> 00:22:05,570
编译器作为这些详细模式

376
00:22:03,799 --> 00:22:07,520
匹配并使用这些 信息 

377
00:22:05,570 --> 00:22:08,179
详细的模式匹配， 以使更好 

378
00:22:07,520 --> 00:22:10,760
决定 

379
00:22:08,179 --> 00:22:12,559
它被称为指令选择和 

380
00:22:10,760 --> 00:22:14,720
有一种可视化的思考方式 

381
00:22:12,559 --> 00:22:19,630
关于它，所以如果我们采取我们的一个 if 

382
00:22:14,720 --> 00:22:19,630
从上面我们可以想到 的方案

383
00:22:22,560 --> 00:22:30,450
程序正在编写，我们已经 完成了 

384
00:22:28,590 --> 00:22:32,240
你可以考虑这个 

385
00:22:30,450 --> 00:22:35,100
一种类似于递归的数据结构 

386
00:22:32,240 --> 00:22:36,510
就像我们的抽象语法树 和我们一样 

387
00:22:35,100 --> 00:22:38,190
通常不会这样画它们

388
00:22:36,510 --> 00:22:41,970
类，但它是 有用 的绘制它 

389
00:22:38,190 --> 00:22:45,990
方式有时让我们想象一下 

390
00:22:41,970 --> 00:22:47,850
如果 表达式是树，则 绘制此图 

391
00:22:45,990 --> 00:22:49,860
所以我们匹配的ifs 

392
00:22:47,850 --> 00:22:52,350
细节有一个if在根然后 a 

393
00:22:49,860 --> 00:22:55,290
大于这 比 符号 少 

394
00:22:52,350 --> 00:22:57,060
然后比这边更大， 

395
00:22:55,290 --> 00:22:59,700
然后有两个表达式并在 

396
00:22:57,060 --> 00:23:03,570
Noah 是一个别的表达 和E 1 

397
00:22:59,700 --> 00:23:05,250
和E 2， 然后我们可以想到的其他 

398
00:23:03,570 --> 00:23:11,280
因为那些是完整的子树 

399
00:23:05,250 --> 00:23:14,220
可能是整个子表达式所以 

400
00:23:11,280 --> 00:23:16,740
如果匹配则整体if匹配 

401
00:23:14,220 --> 00:23:19,290
与我们的任何可能表达相匹配

402
00:23:16,740 --> 00:23:21,750
可以把 它 想象 成 只是处理 

403
00:23:19,290 --> 00:23:26,970
树的这个节点然后它 

404
00:23:21,750 --> 00:23:29,550
处理一切这 整个左 

405
00:23:26,970 --> 00:23:33,690
手侧子树和 这两个子 

406
00:23:29,550 --> 00:23:35,340
树木分开 然后这些分开 

407
00:23:33,690 --> 00:23:37,170
子树会被其他树分解

408
00:23:35,340 --> 00:23:39,000
自然 ，这是我们的 

409
00:23:37,170 --> 00:23:41,100
编译器现在每次 我们 做 

410
00:23:39,000 --> 00:23:43,530
看着这棵树我们来看看 在 一个节点 

411
00:23:41,100 --> 00:23:45,930
树弄清楚如何处理做 

412
00:23:43,530 --> 00:23:47,850
一个节点， 然后递归处理所有 

413
00:23:45,930 --> 00:23:53,570
子树更好有一些 

414
00:23:47,850 --> 00:23:53,570
表达我们更详细的匹配

415
00:24:06,800 --> 00:24:15,750
正在挑选一大块树 

416
00:24:11,250 --> 00:24:17,520
处理更大块的时间 

417
00:24:15,750 --> 00:24:19,860
那个树一次处理和你 

418
00:24:17,520 --> 00:24:21,600
能想到我上面所做的一切 

419
00:24:19,860 --> 00:24:24,600
这个匹配的加法表达式 

420
00:24:21,600 --> 00:24:26,790
加上表达是不同的部分 

421
00:24:24,600 --> 00:24:29,370
从根开始的表达式

422
00:24:26,790 --> 00:24:31,679
是匹配的 ，然后是递归的 

423
00:24:29,370 --> 00:24:36,059
最终得到了处理

424
00:24:31,679 --> 00:24:38,520
递归调用所以其中一 件事 

425
00:24:36,059 --> 00:24:40,860
你会在关于教学的文献中看到

426
00:24:38,520 --> 00:24:42,480
选择， 我不会进去 

427
00:24:40,860 --> 00:24:44,730
深入到这一点，我想指出 ，以 

428
00:24:42,480 --> 00:24:49,170
你这个存在，但我们有有限 

429
00:24:44,730 --> 00:24:53,100
时间131 1 这张照片得到了这个 

430
00:24:49,170 --> 00:24:55,410
在教学选择中的想法是 什么 

431
00:24:53,100 --> 00:24:57,570
我们正在做，我将继续前进 

432
00:24:55,410 --> 00:24:59,820
这个例子下来所以我可以得到这个 

433
00:24:57,570 --> 00:25:02,760
这幅画旁边的照片是我们的 

434
00:24:59,820 --> 00:25:05,250
当 我们选择指令 时， 我们 正在做 

435
00:25:02,760 --> 00:25:12,330
有一些代表我们的树

436
00:25:05,250 --> 00:25:13,710
计划，我们已经得到了所有的 这些 

437
00:25:12,330 --> 00:25:15,300
不同的方式 ，我只是去 

438
00:25:13,710 --> 00:25:19,710
将它们作为这些抽象形状绘制出来

439
00:25:15,300 --> 00:25:21,630
在一边编译节点的子集 

440
00:25:19,710 --> 00:25:23,429
在树中 进入有用的组装 

441
00:25:21,630 --> 00:25:26,250
指令进入有用的目标机器 

442
00:25:23,429 --> 00:25:28,050
说明和我们的编译器是什么

443
00:25:26,250 --> 00:25:32,480
试图用一种方式来查看我们的

444
00:25:28,050 --> 00:25:35,460
编译器的作业是要 找到一个完整的 

445
00:25:32,480 --> 00:25:36,990
覆盖这棵树的平铺 

446
00:25:35,460 --> 00:25:40,410
我们知道 如何编译的 不同方式 

447
00:25:36,990 --> 00:25:44,179
注意所以可能有一个平铺 

448
00:25:40,410 --> 00:25:47,700
涉及用这种颜色抓住这些

449
00:25:44,179 --> 00:25:49,980
抓住这些颜色 抓住 这些 

450
00:25:47,700 --> 00:25:52,590
用这种颜色然后这些 

451
00:25:49,980 --> 00:25:56,220
在这里，这可能是一种可能的方式 

452
00:25:52,590 --> 00:25:58,830
考虑整理这整棵树

453
00:25:56,220 --> 00:26:02,220
通过我们知道的方式将节点转换为 

454
00:25:58,830 --> 00:26:03,690
说明，如果你眯着眼睛看我们的 

455
00:26:02,220 --> 00:26:07,140
您可以想象的模式匹配

456
00:26:03,690 --> 00:26:10,470
这里的紫色区域和 红色 

457
00:26:07,140 --> 00:26:12,290
这里我们的嵌套匹配区域

458
00:26:10,470 --> 00:26:14,720
匹配更多信息， 然后 

459
00:26:12,290 --> 00:26:16,520
最底层的叶子节点就是东西 

460
00:26:14,720 --> 00:26:20,510
就像我们刚才的数字和布尔一样 

461
00:26:16,520 --> 00:26:23,120
直接编译和 策略 

462
00:26:20,510 --> 00:26:25,580
我们在编译器中实现了一个 

463
00:26:23,120 --> 00:26:29,810
从开始贪婪策略 

464
00:26:25,580 --> 00:26:31,580
我们的编译器根本就是贪婪的

465
00:26:29,810 --> 00:26:33,770
匹配从根开始的东西

466
00:26:31,580 --> 00:26:35,750
挑选可以找到的东西 

467
00:26:33,770 --> 00:26:38,690
根和重复的碎片和 

468
00:26:35,750 --> 00:26:39,950
如果有一整套文学作品 

469
00:26:38,690 --> 00:26:42,770
如果你像毕业生一样思考的话 

470
00:26:39,950 --> 00:26:44,900
当然在编译器中或深入研究 

471
00:26:42,770 --> 00:26:47,000
编译器优化有一个完整的 

472
00:26:44,900 --> 00:26:49,150
关于思维方式的文献体

473
00:26:47,000 --> 00:26:51,050
这是一个平铺问题 

474
00:26:49,150 --> 00:26:52,880
表达你所 知道 的不同方式 

475
00:26:51,050 --> 00:26:55,160
如何编译节点的子集和 

476
00:26:52,880 --> 00:26:58,490
试图拿出 一个最佳的平铺 

477
00:26:55,160 --> 00:27:02,450
这棵树，这是一个有趣的 

478
00:26:58,490 --> 00:27:04,190
合理地向前推进的方法

479
00:27:02,450 --> 00:27:06,740
实现这一点的直截了当的方式

480
00:27:04,190 --> 00:27:10,160
这也 与GCC的 做法 有关 

481
00:27:06,740 --> 00:27:12,440
这是一堆手写的 

482
00:27:10,160 --> 00:27:14,450
这从根开始贪婪的规则和 

483
00:27:12,440 --> 00:27:17,390
走下去， 这真的是我们的模式 

484
00:27:14,450 --> 00:27:19,940
匹配在编译函数和

485
00:27:17,390 --> 00:27:23,600
这就是GCC为一个体面的大块做的事情 

486
00:27:19,940 --> 00:27:26,240
它的指令选择等我

487
00:27:23,600 --> 00:27:28,130
只是想把这张照片 放在 这里 

488
00:27:26,240 --> 00:27:31,130
告诉你， 有这个东西 

489
00:27:28,130 --> 00:27:33,860
我们正在 做的是一个实现 

490
00:27:31,130 --> 00:27:35,690
战略 ，有一个整体 

491
00:27:33,860 --> 00:27:37,610
你可以在编译器中完成研究生课程

492
00:27:35,690 --> 00:27:39,200
谈谈这个人写的 

493
00:27:37,610 --> 00:27:42,290
关于如何做聪明的论文

494
00:27:39,200 --> 00:27:44,390
指导选择，但我们是我们 

495
00:27:42,290 --> 00:27:46,280
这种贪婪可以走得很远 

496
00:27:44,390 --> 00:27:47,650
策略从根使用 的 起始 

497
00:27:46,280 --> 00:27:49,880
更多信息 

498
00:27:47,650 --> 00:27:53,180
这样的指令选择和 

499
00:27:49,880 --> 00:27:56,840
这是我们可以 采取我们可以看到的一种方式

500
00:27:53,180 --> 00:27:59,120
从我们现有的编译器和实现 

501
00:27:56,840 --> 00:28:03,050
它自己如何做一点点 

502
00:27:59,120 --> 00:28:04,760
更好地生成汇编代码 

503
00:28:03,050 --> 00:28:07,480
关于这个想法的问题 

504
00:28:04,760 --> 00:28:07,480
高层次的 想法 

505
00:28:12,919 --> 00:28:21,870
好吧所以一个好， 所以我要忍受 

506
00:28:19,320 --> 00:28:24,720
一些汇编代码 

507
00:28:21,870 --> 00:28:26,700
我只是想强调我实际上只是 

508
00:28:24,720 --> 00:28:28,019
我想突出其中的一部分 

509
00:28:26,700 --> 00:28:29,399
想要它，因为我想通过 

510
00:28:28,019 --> 00:28:31,440
今天所有这三个想法都非常 值得强调 

511
00:28:29,399 --> 00:28:32,909
只是一个小片 我 的意思是这 

512
00:28:31,440 --> 00:28:37,460
类似于 我所拥有 的 代码 

513
00:28:32,909 --> 00:28:44,370
周一我要 强调的是 

514
00:28:37,460 --> 00:28:45,960
就在这里，这是你的代码

515
00:28:44,370 --> 00:28:49,139
可能已经在生成的 代码中 看到了 

516
00:28:45,960 --> 00:28:51,000
您的编译器 很多， 但模式 

517
00:28:49,139 --> 00:28:53,100
一遍 又一 遍地 出现 

518
00:28:51,000 --> 00:28:55,200
在我们的编译器的生成代码中 

519
00:28:53,100 --> 00:28:56,639
我们采取斧头中的值来移动它 

520
00:28:55,200 --> 00:28:58,260
到堆栈 然后我们采取 

521
00:28:56,639 --> 00:29:02,010
在 这个堆栈地址值并将其移动 

522
00:28:58,260 --> 00:29:07,919
回到EAX 并且非常高兴 

523
00:29:02,010 --> 00:29:12,360
在那个额外的工作，所以 有一个 

524
00:29:07,919 --> 00:29:14,789
非常直率的直截了当 

525
00:29:12,360 --> 00:29:21,330
方法来处理这种 

526
00:29:14,789 --> 00:29:25,500
这是 关于编译输出的问题

527
00:29:21,330 --> 00:29:27,450
因为我不知道 它是否值得 

528
00:29:25,500 --> 00:29:31,169
称它为蛮力， 但它就像 

529
00:29:27,450 --> 00:29:34,549
这是一个 聪明 的解决方案 

530
00:29:31,169 --> 00:29:37,830
只有它的简单才是这样的一种方式 

531
00:29:34,549 --> 00:29:40,260
谈谈让这更好地避免 

532
00:29:37,830 --> 00:29:44,809
这种情况和编译输出是让我们的 

533
00:29:40,260 --> 00:29:44,809
想象写一个叫做的函数 

534
00:29:55,420 --> 00:30:00,730
提高接受一个指令

535
00:29:58,540 --> 00:30:02,500
指令清单，它会去 

536
00:30:00,730 --> 00:30:04,240
产生一个新的指令列表就这样了 

537
00:30:02,500 --> 00:30:16,270
只是做出指示 

538
00:30:04,240 --> 00:30:18,430
更好，这个想法就是这样 

539
00:30:16,270 --> 00:30:20,620
提高说明会去的 

540
00:30:18,430 --> 00:30:22,450
打印出来之前的编译器

541
00:30:20,620 --> 00:30:24,490
说明正确，我们如何做 

542
00:30:22,450 --> 00:30:25,990
编译器工作我们解析我们编译到 

543
00:30:24,490 --> 00:30:27,550
得到一个指令清单，然后我们

544
00:30:25,990 --> 00:30:29,470
打印出所有说明吧 

545
00:30:27,550 --> 00:30:31,780
这是最后一步， 让我们想象一下 

546
00:30:29,470 --> 00:30:33,040
之前改进了教学清单

547
00:30:31,780 --> 00:30:37,360
将它打印出来让它成为一个 

548
00:30:33,040 --> 00:30:42,750
更好的教学清单，这是一种方法 

549
00:30:37,360 --> 00:30:45,070
这就是这 几乎是一个 

550
00:30:42,750 --> 00:30:47,290
很多我告诉你的 是 

551
00:30:45,070 --> 00:30:51,160
简单的一件事是在实践中完成 ， 

552
00:30:47,290 --> 00:30:55,450
工作让我们的指令匹配 

553
00:30:51,160 --> 00:30:57,760
与和说明，让我们想象一下， 

554
00:30:55,450 --> 00:31:06,840
在指令列表中，我们 的前方 

555
00:30:57,760 --> 00:31:16,590
有一个reg偏移的眼睛移动 

556
00:31:06,840 --> 00:31:26,230
EBP 和一些数字N 和Reg ya X. 

557
00:31:16,590 --> 00:31:29,440
然后是注册斧头和a的眼睛移动 

558
00:31:26,230 --> 00:31:31,620
reg偏移相同的数字 

559
00:31:29,440 --> 00:31:31,620
那里

560
00:31:38,280 --> 00:31:43,210
让我在右边写这个 

561
00:31:40,780 --> 00:31:48,940
模式棘轮风格好吧这样 

562
00:31:43,210 --> 00:31:59,440
与此事相关联的事情 

563
00:31:48,940 --> 00:32:02,170
其余的说明如果

564
00:31:59,440 --> 00:32:03,880
我们到堆栈移动和 EAX 

565
00:32:02,170 --> 00:32:06,880
然后我们将价值从中移开 

566
00:32:03,880 --> 00:32:08,350
堆叠回EAX 我们知道哪个 

567
00:32:06,880 --> 00:32:09,700
指令是冗余的，其 

568
00:32:08,350 --> 00:32:11,400
指令是第一个冗余

569
00:32:09,700 --> 00:32:13,930
第二条指令的说明 

570
00:32:11,400 --> 00:32:15,160
第二个权利我们要把它 移到 

571
00:32:13,930 --> 00:32:16,900
堆栈 ，因为我们可以看看它 

572
00:32:15,160 --> 00:32:18,970
后来我们 绝对不需要 移动 

573
00:32:16,900 --> 00:32:24,340
它从堆栈中退回到EAX中 

574
00:32:18,970 --> 00:32:28,810
现在我们可以采取这个，然后转身 

575
00:32:24,340 --> 00:32:35,170
这是第一条指令 

576
00:32:28,810 --> 00:32:37,350
我用Reg移动第一个 

577
00:32:35,170 --> 00:32:37,350
一

578
00:32:40,240 --> 00:32:45,790
链接到休息说明链接 

579
00:32:44,020 --> 00:32:47,590
intereste 回答 所以只是放下第二个 

580
00:32:45,790 --> 00:32:52,360
指令列表中的指令 

581
00:32:47,590 --> 00:32:54,820
在打印之前应该调整一下 

582
00:32:52,360 --> 00:32:55,900
使其更有用，如 一个调整 

583
00:32:54,820 --> 00:33:00,820
在这里我可以做到这一点 

584
00:32:55,900 --> 00:33:02,920
更有用的是 呼叫提高 

585
00:33:00,820 --> 00:33:04,720
再说一遍，我可以 

586
00:33:02,920 --> 00:33:07,390
递归调用改进指令

587
00:33:04,720 --> 00:33:14,890
其余 只是休息所以 

588
00:33:07,390 --> 00:33:23,140
在这里， 我可以改进说明 

589
00:33:14,890 --> 00:33:34,000
其余的指示是的，是的 

590
00:33:23,140 --> 00:33:35,770
去吧啊有趣 但所以为什么 

591
00:33:34,000 --> 00:33:37,420
为什么我没有说 什么 

592
00:33:35,770 --> 00:33:39,220
关于这些引导 指令如此 

593
00:33:37,420 --> 00:33:41,080
正如我 所说 ，这里发生了什么 

594
00:33:39,220 --> 00:33:42,790
它正在 这个递归中出现 

595
00:33:41,080 --> 00:33:44,410
打电话是我们说我们 要去的 

596
00:33:42,790 --> 00:33:47,920
从 前面处理说明 

597
00:33:44,410 --> 00:33:50,410
如果我们得到指令的前缀

598
00:33:47,920 --> 00:33:52,660
在这里，我们认识到我们可以做到 

599
00:33:50,410 --> 00:33:54,880
我们会 更好地 将它们切掉 

600
00:33:52,660 --> 00:34:03,309
我们会把它们砍掉来回答 你的问题 

601
00:33:54,880 --> 00:34:05,230
问是的所以我们正在 谈论 

602
00:34:03,309 --> 00:34:06,910
这 是我现在的 递归电话 

603
00:34:05,230 --> 00:34:09,070
那种说法 好吧好吧所以我们要去 

604
00:34:06,910 --> 00:34:10,540
然后对其余的进行 递归调用 

605
00:34:09,070 --> 00:34:12,310
这个问题就像我们一样 

606
00:34:10,540 --> 00:34:13,750
删除第一个指令是什么

607
00:34:12,310 --> 00:34:15,399
发生在第一个指令

608
00:34:13,750 --> 00:34:16,780
对， 我们要谈谈 

609
00:34:15,399 --> 00:34:19,090
这个功能有点 的结构

610
00:34:16,780 --> 00:34:21,220
更多，所以我们肯定会再次发生 

611
00:34:19,090 --> 00:34:24,240
这样我们就可以循环其他什么呢 

612
00:34:21,220 --> 00:34:24,240
我们需要 担心 的是啊是啊 

613
00:34:27,880 --> 00:34:32,210
所以我们可以打电话给改进 

614
00:34:30,020 --> 00:34:33,679
关于整件事的说明正确 

615
00:34:32,210 --> 00:34:35,810
因为我们可能已经嘎吱嘎吱 

616
00:34:33,679 --> 00:34:38,120
指令一起在前面 那个 

617
00:34:35,810 --> 00:34:39,770
然后再做一个模式匹配我们 

618
00:34:38,120 --> 00:34:41,179
也可以改善我们的权利 

619
00:34:39,770 --> 00:34:50,960
这样做可能是另一个 

620
00:34:41,179 --> 00:34:54,880
这里的方法就是打电话来打电话 

621
00:34:50,960 --> 00:34:58,370
改善对这件事的指示

622
00:34:54,880 --> 00:34:59,780
是的，让我们一定要做 

623
00:34:58,370 --> 00:35:00,920
当我们这样做时，列表会变小，所以我们

624
00:34:59,780 --> 00:35:02,810
不必 担心它是一个 

625
00:35:00,920 --> 00:35:04,340
无限循环， 因为 我们只要我们 

626
00:35:02,810 --> 00:35:06,980
最终使列表变小 

627
00:35:04,340 --> 00:35:08,810
我们会坐下来 一个 空的列表 或 一些 

628
00:35:06,980 --> 00:35:09,860
固定大小的列表， 但我们可以 

629
00:35:08,810 --> 00:35:11,300
只是 在 整个事情 上 调用 它 

630
00:35:09,860 --> 00:35:13,670
也许这表明了一些新的模式

631
00:35:11,300 --> 00:35:15,470
这将 是真正的问题是什么 

632
00:35:13,670 --> 00:35:16,970
如果没有模式匹配，但 我认为是 

633
00:35:15,470 --> 00:35:19,010
我认为其实什么 是 

634
00:35:16,970 --> 00:35:20,660
你的问题正确，因为 

635
00:35:19,010 --> 00:35:23,000
如果我们这样做 ，我们会怎么做 

636
00:35:20,660 --> 00:35:24,710
只是这整个名单上的功能它 

637
00:35:23,000 --> 00:35:27,290
只会说好的 没有比赛没有比赛 

638
00:35:24,710 --> 00:35:29,090
工作正确你说它说移动EBP 

639
00:35:27,290 --> 00:35:31,940
顶部的ESP 无关 

640
00:35:29,090 --> 00:35:33,620
你建议的比赛所以 

641
00:35:31,940 --> 00:35:35,150
我们要做的事情是我们需要的，我们可能 

642
00:35:33,620 --> 00:35:38,090
有更多的情况我们知道如何 

643
00:35:35,150 --> 00:35:40,220
改善这里的指示， 但我们 

644
00:35:38,090 --> 00:35:42,770
我们需要一些结局案例 

645
00:35:40,220 --> 00:35:44,630
指令与其他部分相关联 

646
00:35:42,770 --> 00:35:46,850
说明和我们说 没事 

647
00:35:44,630 --> 00:35:49,520
没有任何匹配让我们向前迈进 

648
00:35:46,850 --> 00:35:57,430
列表，让我们把它 变成我 

649
00:35:49,520 --> 00:35:59,800
联系以 改善指示骚乱 

650
00:35:57,430 --> 00:36:01,880
因为我们无法 做到 

651
00:35:59,800 --> 00:36:03,740
如果它不匹配的话 

652
00:36:01,880 --> 00:36:06,410
任何我们可以工作 的 模式 

653
00:36:03,740 --> 00:36:07,910
所以这里的想法就是这样 

654
00:36:06,410 --> 00:36:10,100
我们将遍历整个 列表 

655
00:36:07,910 --> 00:36:11,600
说明 ，每次我们找到 

656
00:36:10,100 --> 00:36:13,700
我们知道怎么做的小前缀 

657
00:36:11,600 --> 00:36:14,870
改善 我们会缩小那个然后 

658
00:36:13,700 --> 00:36:19,010
我们会看到，如果我们 可以做的更好 的 

659
00:36:14,870 --> 00:36:23,330
还剩下什么，所以这是非常的 

660
00:36:19,010 --> 00:36:25,040
具体非常类似我 猜的直率 

661
00:36:23,330 --> 00:36:26,510
这是个好词， 有一个列表 

662
00:36:25,040 --> 00:36:27,770
说明 ，我们看到说明 

663
00:36:26,510 --> 00:36:29,990
彼此相邻，我们可以改进 

664
00:36:27,770 --> 00:36:32,630
让我们改进 它们并把新的 

665
00:36:29,990 --> 00:36:34,810
在地方和更好的说明

666
00:36:32,630 --> 00:36:39,100
这里的想法是我们 运行一点点 

667
00:36:34,810 --> 00:36:39,100
窗口我们可以把它想象成 一 点点 

668
00:36:39,369 --> 00:36:48,309
沿着序列的一个小窗口 

669
00:36:46,059 --> 00:36:54,880
说明 ，这是一个小点 

670
00:36:48,309 --> 00:36:57,249
我们偷窥并尝试使用的地方 

671
00:36:54,880 --> 00:36:58,900
非常非常本地化的信息 

672
00:36:57,249 --> 00:37:01,690
一个，两个或 三个或四个 指令 

673
00:36:58,900 --> 00:37:06,299
时间让事情变得更好 一点点 

674
00:37:01,690 --> 00:37:15,609
这个想法 有一个名字peephole 

675
00:37:06,299 --> 00:37:20,289
优化，这是一个超级 

676
00:37:15,609 --> 00:37:22,299
普通它也相对一个不错 

677
00:37:20,289 --> 00:37:24,700
这个特点就是它没有 

678
00:37:22,299 --> 00:37:27,160
要求了解 其余部分 

679
00:37:24,700 --> 00:37:28,900
编译器中的一些 知道嵌套 

680
00:37:27,160 --> 00:37:31,390
匹配需要了解很多

681
00:37:28,900 --> 00:37:33,039
关于每个表达式的假设 

682
00:37:31,390 --> 00:37:35,470
做什么以及它可能有什么错误 

683
00:37:33,039 --> 00:37:38,230
它可以拥有什么标签

684
00:37:35,470 --> 00:37:40,059
通过了解x86是什么来实现 

685
00:37:38,230 --> 00:37:42,249
应该做对你只需要 

686
00:37:40,059 --> 00:37:44,019
知道x86这样做 是因为你 

687
00:37:42,249 --> 00:37:45,730
只需要知道那 不可能 

688
00:37:44,019 --> 00:37:47,789
第二条指令不可能

689
00:37:45,730 --> 00:37:51,489
有用， 因为它只是在做 

690
00:37:47,789 --> 00:37:53,079
不必要的工作，所以它是那种 

691
00:37:51,489 --> 00:37:56,619
独立于编译器的其余部分 

692
00:37:53,079 --> 00:37:58,839
这很好，而且非常好 

693
00:37:56,619 --> 00:38:00,279
只是循环遍历指令

694
00:37:58,839 --> 00:38:03,839
看着 几个 旁边， 是 每个 

695
00:38:00,279 --> 00:38:03,839
其他 一次是的 

696
00:38:11,640 --> 00:38:16,119
所以，让我们记住让我们留下来 

697
00:38:14,559 --> 00:38:17,710
请注意，你的评论 是 正确的 

698
00:38:16,119 --> 00:38:19,960
也许我们可以完成 整个过程 

699
00:38:17,710 --> 00:38:22,390
列表 ，我们没有找到任何说明 

700
00:38:19,960 --> 00:38:25,690
改进，但我想指出 

701
00:38:22,390 --> 00:38:27,910
花在那里的 时间不是编译时间 

702
00:38:25,690 --> 00:38:29,319
运行时间正确，这很漂亮 

703
00:38:27,910 --> 00:38:32,079
这实际上是一个重要的区别 

704
00:38:29,319 --> 00:38:34,029
在所有这些权利中，这些 

705
00:38:32,079 --> 00:38:36,430
匹配更多的优化

706
00:38:34,029 --> 00:38:38,710
一些喜欢平铺或做的东西 

707
00:38:36,430 --> 00:38:40,420
这种人优化都是成本

708
00:38:38,710 --> 00:38:42,220
编译时间， 我们正在交易 

709
00:38:40,420 --> 00:38:46,809
努力， 以便最终的计划 

710
00:38:42,220 --> 00:38:49,150
我经常给出的例子运行得更快

711
00:38:46,809 --> 00:38:52,960
因为如果你是你知道的话 

712
00:38:49,150 --> 00:38:55,720
适合Firefox的项目经理 

713
00:38:52,960 --> 00:38:57,640
你会，你应该能够并且 应该 

714
00:38:55,720 --> 00:38:59,319
如果你是 某人的权衡

715
00:38:57,640 --> 00:39:02,410
给你一个优化编译器

716
00:38:59,319 --> 00:39:05,920
花了一个星期的时间 来运行但是让Firefox如此 

717
00:39:02,410 --> 00:39:08,559
你可以并且应该雇用服务器 

718
00:39:05,920 --> 00:39:10,779
编译Firefox一周然后

719
00:39:08,559 --> 00:39:12,609
二进制一次发布的那个

720
00:39:10,779 --> 00:39:14,950
为您的数百万用户提供更快的权利 

721
00:39:12,609 --> 00:39:15,819
所以这是你的 问题 非常好 

722
00:39:14,950 --> 00:39:18,099
因为它 正是如此 

723
00:39:15,819 --> 00:39:20,019
权衡权利Mozilla应该感到高兴 

724
00:39:18,099 --> 00:39:22,329
运行最好的窥视孔优化器 

725
00:39:20,019 --> 00:39:24,400
在这个世界上，如果能节省我一天的话 

726
00:39:22,329 --> 00:39:30,730
第二个权利，因为我是数百万之一 

727
00:39:24,400 --> 00:39:32,940
用户可以， 所以让我们看到最后 

728
00:39:30,730 --> 00:39:38,890
我想谈谈的 想法 

729
00:39:32,940 --> 00:39:41,680
今天是我想的 几个 

730
00:39:38,890 --> 00:39:45,430
房间的不同区域 长大了 

731
00:39:41,680 --> 00:39:47,289
周一 我们刚刚说话的时候 

732
00:39:45,430 --> 00:39:51,309
有点头脑风暴的改进方法

733
00:39:47,289 --> 00:39:53,650
改进编译器并且有 

734
00:39:51,309 --> 00:39:54,940
事情就像这样， 这是 

735
00:39:53,650 --> 00:39:58,119
在例子中出现的东西 

736
00:39:54,940 --> 00:40:03,000
我是在课堂上画的第一个

737
00:39:58,119 --> 00:40:03,000
我们写的程序就是这样的

738
00:40:10,140 --> 00:40:16,810
这就像第二周 或者回来的那样 

739
00:40:13,360 --> 00:40:20,890
三 ，你们 很多 人都像乔一样 

740
00:40:16,810 --> 00:40:24,520
我知道这就产生了 八个原因 

741
00:40:20,890 --> 00:40:27,220
编译二进制权，就像那样 

742
00:40:24,520 --> 00:40:29,170
你没有在那里取得多少成就

743
00:40:27,220 --> 00:40:32,830
编译该程序然后运行 

744
00:40:29,170 --> 00:40:36,040
并有两个观察使 

745
00:40:32,830 --> 00:40:40,290
关于这个程序， 一个就是那个 

746
00:40:36,040 --> 00:40:54,250
在这里它是一个表达式

747
00:40:40,290 --> 00:40:56,560
添加两个常数，然后是 

748
00:40:54,250 --> 00:41:03,880
另一个稍微微妙的事情 

749
00:40:56,560 --> 00:41:16,660
在这里 这是一个使用 

750
00:41:03,880 --> 00:41:19,030
变量，我们知道它的价值，而我

751
00:41:16,660 --> 00:41:21,790
把知识放在引号中因为我们是 

752
00:41:19,030 --> 00:41:24,370
人们对此做了很多推理 

753
00:41:21,790 --> 00:41:26,110
确保我们理解 我们是 

754
00:41:24,370 --> 00:41:28,570
添加三分之一，这是不会做的 

755
00:41:26,110 --> 00:41:30,400
任何像溢出的权利，但X是 

756
00:41:28,570 --> 00:41:31,960
一些变量，我们知道它的价值 

757
00:41:30,400 --> 00:41:34,150
将是四个，没有办法 

758
00:41:31,960 --> 00:41:35,620
当我们运行它时，值不会是4 

759
00:41:34,150 --> 00:41:38,850
程序所以有两个不同的 东西 

760
00:41:35,620 --> 00:41:41,110
继续我们在那里使用 

761
00:41:38,850 --> 00:41:42,460
聪明人才知道 这一点 

762
00:41:41,110 --> 00:41:46,330
程序 将 产生这个答案 

763
00:41:42,460 --> 00:41:47,860
实际上有时会发生一件事

764
00:41:46,330 --> 00:41:50,980
在第一对编程中 

765
00:41:47,860 --> 00:41:53,260
本课程的作业是人

766
00:41:50,980 --> 00:41:55,930
写的 是复杂的编译器

767
00:41:53,260 --> 00:41:57,760
他们这样做是因为他们 

768
00:41:55,930 --> 00:42:01,600
可能实现了一个翻译 

769
00:41:57,760 --> 00:42:03,490
CS c130 如果他们编译了这个 

770
00:42:01,600 --> 00:42:05,910
程序让我们只调用这个 程序P. 

771
00:42:03,490 --> 00:42:05,910
目前

772
00:42:07,360 --> 00:42:12,610
我们编译了P类的意义 

773
00:42:10,960 --> 00:42:15,070
什么是我们可以做的最好的编译 

774
00:42:12,610 --> 00:42:19,260
这个程序很好，如果我们这样会很好 

775
00:42:15,070 --> 00:42:19,260
可以将此程序编译为 移动 EA 

776
00:42:22,170 --> 00:42:28,210
x17对，因为 那是 

777
00:42:23,950 --> 00:42:30,490
的八表示，这将是 

778
00:42:28,210 --> 00:42:33,790
很酷， 如果我们编译这个程序的话 

779
00:42:30,490 --> 00:42:36,220
只是把 答案变成了答案 

780
00:42:33,790 --> 00:42:38,050
EAX 还有 竟是 几个你 

781
00:42:36,220 --> 00:42:41,080
谁做了这样的事我很善良 

782
00:42:38,050 --> 00:42:43,240
它实际上有点 放慢你的速度 

783
00:42:41,080 --> 00:42:45,130
当你需要解析一个处理时

784
00:42:43,240 --> 00:42:47,320
输入，因为你无法处理所有 

785
00:42:45,130 --> 00:42:49,240
可能即将来临的未知价值

786
00:42:47,320 --> 00:42:51,520
进入一个程序， 但对于 一个程序 

787
00:42:49,240 --> 00:42:54,610
我们实际可以写的所有已知值

788
00:42:51,520 --> 00:42:56,320
进入我们的编译器就足够聪明了 

789
00:42:54,610 --> 00:42:58,210
它可以弄清楚这些常数是什么 

790
00:42:56,320 --> 00:43:04,540
应该并生成更好的代码 

791
00:42:58,210 --> 00:43:05,890
对于其中一些案例和我们的一种方式 

792
00:43:04,540 --> 00:43:08,170
能做到这一点 是 我们能做到的 

793
00:43:05,890 --> 00:43:10,060
这基于 我们迄今为止所知道的方式 

794
00:43:08,170 --> 00:43:13,950
可以这么说，也许是绿色的东西

795
00:43:10,060 --> 00:43:13,950
基于我们目前所知的+1 3 

796
00:43:17,400 --> 00:43:20,400
是啊

797
00:43:29,910 --> 00:43:42,520
对，所以一个想法是一个好主意

798
00:43:37,600 --> 00:43:49,540
想做 选择权的 想法 

799
00:43:42,520 --> 00:43:53,920
我们可以说 用一个 来表达+ 

800
00:43:49,540 --> 00:43:56,050
Eden嗯和enum这是一个特殊的 

801
00:43:53,920 --> 00:43:57,760
编译权可能 只是添加 

802
00:43:56,050 --> 00:44:00,160
将这 两个数字放在一起 并编译成 

803
00:43:57,760 --> 00:44:03,550
一个单一的移动指令就是一个 

804
00:44:00,160 --> 00:44:08,650
想法但它对 我们 没有帮助 

805
00:44:03,550 --> 00:44:10,420
这个X变量的其他问题是哪个 

806
00:44:08,650 --> 00:44:11,920
价值我们知道这些事情之一 

807
00:44:10,420 --> 00:44:13,600
好像它可能是一个指令 

808
00:44:11,920 --> 00:44:15,040
选择这样的事情， 但 其他 

809
00:44:13,600 --> 00:44:16,510
一个看起来不像是一个 

810
00:44:15,040 --> 00:44:18,940
指令选择的东西

811
00:44:16,510 --> 00:44:20,770
特别是如果那个X使用那个X. 

812
00:44:18,940 --> 00:44:25,390
有点远离它的位置 

813
00:44:20,770 --> 00:44:27,520
定义但这些是相关的想法 

814
00:44:25,390 --> 00:44:30,400
因为他们都与价值观有关 

815
00:44:27,520 --> 00:44:33,610
我们 我们知道当我们编译 

816
00:44:30,400 --> 00:44:35,050
程序必须 是我们特定的价值 

817
00:44:33,610 --> 00:44:40,890
不需要等待并运行程序 

818
00:44:35,050 --> 00:44:43,630
搞清楚它们是什么值，因此 

819
00:44:40,890 --> 00:44:48,580
这里有一个我们可以 使用的想法

820
00:44:43,630 --> 00:44:50,910
而不是写而不是写 

821
00:44:48,580 --> 00:44:55,980
使这部分编译功能

822
00:44:50,910 --> 00:45:00,280
并本着 我们刚刚所做 的精神 

823
00:44:55,980 --> 00:45:02,890
对于人们的 优化让我们想象一下 

824
00:45:00,280 --> 00:45:09,430
函数调用提高表达式 

825
00:45:02,890 --> 00:45:12,580
采取表达并产生一个

826
00:45:09,430 --> 00:45:15,280
表达式 ， 更好是 

827
00:45:12,580 --> 00:45:18,310
较短或较少的子 

828
00:45:15,280 --> 00:45:22,050
表达式或以某种方式减少工作量

829
00:45:18,310 --> 00:45:22,050
让我们想象一下，我们可以写出来 

830
00:45:22,230 --> 00:45:26,280
改善表达 

831
00:45:32,339 --> 00:45:35,369
这里的第一个案例是 你 

832
00:45:34,049 --> 00:45:36,809
建议那就像 

833
00:45:35,369 --> 00:45:38,849
指令选择版本

834
00:45:36,809 --> 00:45:42,450
如果我们想要的话，这是正确的 

835
00:45:38,849 --> 00:45:45,269
改进有优势的EEPROM 工具 

836
00:45:42,450 --> 00:45:53,489
第一个位置然后是eID麻木 

837
00:45:45,269 --> 00:45:57,900
和1和E 麻木 - 什么是 更好 

838
00:45:53,489 --> 00:45:59,430
这个表达式内存的版本应该 

839
00:45:57,900 --> 00:46:02,999
有一个更好的类型表达式 

840
00:45:59,430 --> 00:46:05,369
这个表达式 的 版本 更好 

841
00:46:02,999 --> 00:46:09,509
使用的表达式比这个 

842
00:46:05,369 --> 00:46:18,930
我们想要一种更快捷的方式 

843
00:46:09,509 --> 00:46:25,440
同样的结果是的，所以一个建议

844
00:46:18,930 --> 00:46:28,499
用一些 进入EAX + 1 + + 2 

845
00:46:25,440 --> 00:46:29,489
字符串字符串填写什么问题 

846
00:46:28,499 --> 00:46:31,140
与这又会有什么问题 

847
00:46:29,489 --> 00:46:32,519
它不是一个坏主意，这有点 的 

848
00:46:31,140 --> 00:46:37,440
与指令选择相同的想法 

849
00:46:32,519 --> 00:46:42,599
想法是啊是啊也许有一些

850
00:46:37,440 --> 00:46:44,640
转向做它是啊 

851
00:46:42,599 --> 00:46:46,109
溢出还有其他什么东西 

852
00:46:44,640 --> 00:46:49,289
还有更多的东西 

853
00:46:46,109 --> 00:46:52,469
关于我如何决定写这个 

854
00:46:49,289 --> 00:46:58,920
改善表达功能我应该 

855
00:46:52,469 --> 00:47:00,450
打扰你，是的，是的，我们 

856
00:46:58,920 --> 00:47:01,710
只是想要返回一个表达式 

857
00:47:00,450 --> 00:47:03,960
如果我们开始把它变成 

858
00:47:01,710 --> 00:47:05,789
说明就像是一个 

859
00:47:03,960 --> 00:47:08,130
没有骆驼级别的类型错误，所以我得到了

860
00:47:05,789 --> 00:47:10,890
这个想法与这个想法不同 

861
00:47:08,130 --> 00:47:12,839
根据这个选择说明 

862
00:47:10,890 --> 00:47:20,969
想要一个我想要的东西 

863
00:47:12,839 --> 00:47:24,210
类型表达式是+ 1 + +的枚举 

864
00:47:20,969 --> 00:47:26,819
那是非常有趣的 

865
00:47:24,210 --> 00:47:28,950
非常有趣 我可以参加 

866
00:47:26,819 --> 00:47:30,719
表达，你知道我们会做一些 

867
00:47:28,950 --> 00:47:32,339
我们会做通常的递归事情 

868
00:47:30,719 --> 00:47:34,469
表达所以我们会找到任何子 

869
00:47:32,339 --> 00:47:36,390
其他匹配案例中的表达式

870
00:47:34,469 --> 00:47:38,400
但如果我们找到的东西 ，这是一个 

871
00:47:36,390 --> 00:47:40,529
原始的，它是 两个加号

872
00:47:38,400 --> 00:47:42,509
数字， 我们可以取代它 

873
00:47:40,529 --> 00:47:45,089
表达式的数字是 

874
00:47:42,509 --> 00:47:47,540
另外的那 两个东西 ，你只是 

875
00:47:45,089 --> 00:47:49,619
替换 它 

876
00:47:47,540 --> 00:47:51,210
我们不得不担心一些 

877
00:47:49,619 --> 00:47:52,829
溢出，我们可能需要 把它变成 

878
00:47:51,210 --> 00:47:56,220
表达式 抛出的东西

879
00:47:52,829 --> 00:47:58,109
溢出错误， 如果它们溢出 但是 

880
00:47:56,220 --> 00:47:59,369
如果他们不溢出这 是 

881
00:47:58,109 --> 00:48:02,700
肯定会产生 相同的 

882
00:47:59,369 --> 00:48:07,650
回答这很有意思 

883
00:48:02,700 --> 00:48:10,619
非常有趣的有啥这个 

884
00:48:07,650 --> 00:48:18,630
另一个案例我们谈过这个案子

885
00:48:10,619 --> 00:48:24,570
我将要 做到这一点 

886
00:48:18,630 --> 00:48:27,720
稍微简单的情况只是为了我要去 

887
00:48:24,570 --> 00:48:29,670
想象一下，有一个数字 

888
00:48:27,720 --> 00:48:32,940
不是没有一些复合表达 

889
00:48:29,670 --> 00:48:35,900
但左边的数字让绑定 

890
00:48:32,940 --> 00:48:38,940
我们如何改善这一点

891
00:48:35,900 --> 00:48:40,410
表达我们怎样才能 改善这一点 

892
00:48:38,940 --> 00:48:43,500
表达我们知道有一个数字 

893
00:48:40,410 --> 00:48:45,560
有没有 X，我们可以做，使该 

894
00:48:43,500 --> 00:48:45,560
更好 

895
00:49:05,380 --> 00:49:08,069
是啊

896
00:49:12,650 --> 00:49:17,220
所以建议是，我们必须 

897
00:49:15,510 --> 00:49:21,780
想到类型是有意义的让我们 

898
00:49:17,220 --> 00:49:25,740
想象一下，我们有一些 你想要的 帮手 

899
00:49:21,780 --> 00:49:32,850
用枚举替换X的所有实例 

900
00:49:25,740 --> 00:49:34,650
的 在主体N， 其中替换将要 

901
00:49:32,850 --> 00:49:36,860
必须是我们的其他一些辅助功能

902
00:49:34,650 --> 00:49:36,860
对 

903
00:49:50,980 --> 00:49:55,010
那很有意思

904
00:49:52,940 --> 00:49:59,080
因此这表明 ， 也许我们有这个 

905
00:49:55,010 --> 00:50:02,240
我们可以做的其他改造

906
00:49:59,080 --> 00:50:05,780
表达式，如果我们知道a 

907
00:50:02,240 --> 00:50:09,680
特定的标识符总是如此 

908
00:50:05,780 --> 00:50:11,450
被绑定到我们可以相同的价值 

909
00:50:09,680 --> 00:50:14,900
到处替换它的 价值 

910
00:50:11,450 --> 00:50:17,180
我们不再需要那个了 

911
00:50:14,900 --> 00:50:19,100
变量 在 咱们的工作是 

912
00:50:17,180 --> 00:50:20,870
有价值的地方生活 

913
00:50:19,100 --> 00:50:23,030
在我们评估之后我们可以看一下

914
00:50:20,870 --> 00:50:24,740
它多次，但 如果我们知道什么 

915
00:50:23,030 --> 00:50:26,300
这 是没有理由 去的 

916
00:50:24,740 --> 00:50:28,340
存储它并查找多个 

917
00:50:26,300 --> 00:50:31,520
当我们得到时 ，我们只是使用那个值 

918
00:50:28,340 --> 00:50:35,360
如果我们可以取代所有的 

919
00:50:31,520 --> 00:50:38,330
Eid X在体内的实例

920
00:50:35,360 --> 00:50:40,370
然后 我们得到 那个 数字表达式 

921
00:50:38,330 --> 00:50:41,870
节省 查找 该变量的时间 

922
00:50:40,370 --> 00:50:43,220
每次遇到它我们永远不会 

923
00:50:41,870 --> 00:50:44,680
必须将变量存储在第一个中 

924
00:50:43,220 --> 00:50:47,300
地点 

925
00:50:44,680 --> 00:50:48,560
所以只是给出这些的定义

926
00:50:47,300 --> 00:50:51,920
事我想我会谈 一 点点 

927
00:50:48,560 --> 00:50:54,770
这个案子 周五 更多关于他们 

928
00:50:51,920 --> 00:50:57,110
所谓主要所以如果你想看看 

929
00:50:54,770 --> 00:50:59,480
他们这种情况称为常数 

930
00:50:57,110 --> 00:51:01,990
传播你采取常数和移动 

931
00:50:59,480 --> 00:51:01,990
他们到了 

